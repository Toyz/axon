package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/toyz/axon/internal/models"
	"github.com/toyz/axon/internal/registry"
	"github.com/toyz/axon/internal/templates"
	"github.com/toyz/axon/pkg/axon"
)

// ParserRegistryInterface defines the interface for parser registry operations
type ParserRegistryInterface interface {
	RegisterParser(parser models.RouteParserMetadata) error
	GetParser(typeName string) (models.RouteParserMetadata, bool)
	ListParsers() []string
	HasParser(typeName string) bool
	Clear()
	ClearCustomParsers()
	GetAllParsers() map[string]models.RouteParserMetadata
}

// Generator implements the CodeGenerator interface
type Generator struct {
	moduleResolver ModuleResolver
	parserRegistry ParserRegistryInterface
}

// ModuleResolver interface for resolving module paths
type ModuleResolver interface {
	ResolveModuleName(customName string) (string, error)
	BuildPackagePath(moduleName, packageDir string) (string, error)
}

// NewGenerator creates a new code generator instance
func NewGenerator() *Generator {
	return &Generator{
		parserRegistry: registry.NewParserRegistry(),
	}
}

// NewGeneratorWithResolver creates a new code generator instance with a module resolver
func NewGeneratorWithResolver(resolver ModuleResolver) *Generator {
	return &Generator{
		moduleResolver: resolver,
		parserRegistry: registry.NewParserRegistry(),
	}
}

// GenerateModule generates a complete FX module file for a package with annotations
func (g *Generator) GenerateModule(metadata *models.PackageMetadata) (*models.GeneratedModule, error) {
	return g.GenerateModuleWithModule(metadata, "")
}

// GenerateModuleWithModule generates a complete FX module file for a package with annotations and module name
func (g *Generator) GenerateModuleWithModule(metadata *models.PackageMetadata, moduleName string) (*models.GeneratedModule, error) {
	if metadata == nil {
		return nil, fmt.Errorf("metadata cannot be nil")
	}

	// Determine the output file path
	filePath := filepath.Join(metadata.PackagePath, "autogen_module.go")

	// Generate the module content based on what annotations are present
	var content string
	var err error

	if len(metadata.Controllers) > 0 {
		// Generate controller module
		content, err = g.generateControllerModuleWithModule(metadata, moduleName)
	} else if len(metadata.Middlewares) > 0 {
		// Generate middleware module
		content, err = g.generateMiddlewareModule(metadata)
	} else if len(metadata.CoreServices) > 0 || len(metadata.Interfaces) > 0 || len(metadata.Loggers) > 0 {
		// Generate core services module (includes loggers)
		content, err = templates.GenerateCoreServiceModuleWithModule(metadata, moduleName)
	} else {
		// Empty module
		content = g.generateEmptyModule(metadata)
	}

	if err != nil {
		return nil, fmt.Errorf("failed to generate module content: %w", err)
	}

	// Extract providers from the metadata
	providers := g.extractProviders(metadata)

	return &models.GeneratedModule{
		PackageName: metadata.PackageName,
		FilePath:    filePath,
		Content:     content,
		Providers:   providers,
	}, nil
}

// generateControllerModule generates a module file for packages with controllers
func (g *Generator) generateControllerModule(metadata *models.PackageMetadata) (string, error) {
	return g.generateControllerModuleWithModule(metadata, "")
}

// generateControllerModuleWithModule generates a module file for packages with controllers with module name
func (g *Generator) generateControllerModuleWithModule(metadata *models.PackageMetadata, moduleName string) (string, error) {
	var moduleBuilder strings.Builder

	// Generate package declaration with DO NOT EDIT header
	moduleBuilder.WriteString("// Code generated by Axon framework. DO NOT EDIT.\n")
	moduleBuilder.WriteString("// This file was automatically generated and should not be modified manually.\n\n")
	moduleBuilder.WriteString(fmt.Sprintf("package %s\n\n", metadata.PackageName))

	// Analyze what imports are needed by examining the metadata
	imports := g.analyzeRequiredImports(metadata, moduleName)
	
	// Generate imports
	moduleBuilder.WriteString("import (\n")
	
	// Standard library imports first
	for _, imp := range imports.StandardLibrary {
		moduleBuilder.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
	}
	
	if len(imports.StandardLibrary) > 0 && (len(imports.ThirdParty) > 0 || len(imports.Local) > 0) {
		moduleBuilder.WriteString("\n")
	}
	
	// Third party imports
	for _, imp := range imports.ThirdParty {
		moduleBuilder.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
	}
	
	if len(imports.ThirdParty) > 0 && len(imports.Local) > 0 {
		moduleBuilder.WriteString("\n")
	}
	
	// Local imports with aliases
	for _, importSpec := range imports.Local {
		if importSpec.Alias != "" {
			moduleBuilder.WriteString(fmt.Sprintf("\t%s \"%s\"\n", importSpec.Alias, importSpec.Path))
		} else {
			moduleBuilder.WriteString(fmt.Sprintf("\t\"%s\"\n", importSpec.Path))
		}
	}
	
	moduleBuilder.WriteString(")\n\n")
	
	// Add type aliases for imported types if needed
	for alias, typeName := range imports.TypeAliases {
		moduleBuilder.WriteString(fmt.Sprintf("type %s = %s\n", alias, typeName))
	}
	if len(imports.TypeAliases) > 0 {
		moduleBuilder.WriteString("\n")
	}

	// Generate controller providers
	for _, controller := range metadata.Controllers {
		providerCode, err := g.generateControllerProvider(controller)
		if err != nil {
			return "", fmt.Errorf("failed to generate provider for controller %s: %w", controller.Name, err)
		}
		moduleBuilder.WriteString(providerCode)
		moduleBuilder.WriteString("\n\n")
	}

	// Generate route wrapper functions
	for _, controller := range metadata.Controllers {
		for _, route := range controller.Routes {
			wrapperCode, err := templates.GenerateRouteWrapper(route, controller.StructName, g.parserRegistry)
			if err != nil {
				return "", fmt.Errorf("failed to generate wrapper for route %s.%s: %w", controller.Name, route.HandlerName, err)
			}
			moduleBuilder.WriteString(wrapperCode)
			moduleBuilder.WriteString("\n\n")
		}
	}

	// Generate route registration function
	registrationCode, err := g.generateRouteRegistrationFunction(metadata)
	if err != nil {
		return "", fmt.Errorf("failed to generate route registration function: %w", err)
	}
	moduleBuilder.WriteString(registrationCode)
	moduleBuilder.WriteString("\n\n")

	// Generate module variable
	moduleCode := g.generateControllerModuleVariable(metadata)
	moduleBuilder.WriteString(moduleCode)

	return moduleBuilder.String(), nil
}

// generateControllerProvider generates an FX provider for a controller
func (g *Generator) generateControllerProvider(controller models.ControllerMetadata) (string, error) {
	// Convert dependencies to template data
	var deps []templates.DependencyData
	var injectedDeps []templates.DependencyData
	
	for _, dep := range controller.Dependencies {
		// Use the actual field name, converted to camelCase for parameter
		paramName := strings.ToLower(dep.Name[:1]) + dep.Name[1:]
		depData := templates.DependencyData{
			Name:      paramName,
			FieldName: dep.Name,
			Type:      dep.Type,
			IsInit:    dep.IsInit,
		}
		deps = append(deps, depData)
		
		// Only add to injected deps if it's not an init dependency
		if !dep.IsInit {
			injectedDeps = append(injectedDeps, depData)
		}
	}

	data := templates.CoreServiceProviderData{
		StructName:   controller.StructName,
		Dependencies: deps,
		InjectedDeps: injectedDeps,
		HasStart:     false,
		HasStop:      false,
	}

	return templates.ExecuteTemplate("controller-provider", templates.ProviderTemplate, data)
}

// ImportAnalysis represents the analyzed imports needed for code generation
type ImportAnalysis struct {
	StandardLibrary []string            // Standard library imports like "net/http"
	ThirdParty      []string            // Third party imports like "github.com/labstack/echo/v4"
	Local           []ImportSpec        // Local imports with optional aliases
	TypeAliases     map[string]string   // Type aliases: alias -> full type name
}

// ImportSpec represents an import specification
type ImportSpec struct {
	Alias string // Optional alias, empty string means no alias
	Path  string // Import path
}

// analyzeRequiredImports analyzes the metadata to determine what imports are needed
func (g *Generator) analyzeRequiredImports(metadata *models.PackageMetadata, moduleName string) ImportAnalysis {
	analysis := ImportAnalysis{
		StandardLibrary: []string{},
		ThirdParty:      []string{},
		Local:           []ImportSpec{},
		TypeAliases:     make(map[string]string),
	}
	
	// Always needed for controllers
	analysis.StandardLibrary = append(analysis.StandardLibrary, "net/http", "strconv")
	analysis.ThirdParty = append(analysis.ThirdParty, 
		"github.com/labstack/echo/v4",
		"go.uber.org/fx",
		"github.com/toyz/axon/pkg/axon")
	
	// Analyze controller dependencies for service imports
	servicePackages := make(map[string]bool)
	for _, controller := range metadata.Controllers {
		for _, dep := range controller.Dependencies {
			if packageName := g.extractPackageFromType(dep.Type); packageName != "" {
				servicePackages[packageName] = true
			}
		}
	}
	
	// Analyze route parameters for model imports and parser imports
	modelPackages := make(map[string]bool)
	parserPackages := make(map[string]bool)
	hasUUIDParams := false
	hasCustomParsers := false
	addedPaths := make(map[string]bool) // Track added paths to avoid duplicates
	for _, controller := range metadata.Controllers {
		for _, route := range controller.Routes {
			for _, param := range route.Parameters {
				// Resolve type alias to check for imports
				resolvedType := axon.ResolveTypeAlias(param.Type)
				
				// Check for UUID parameters (including alias)
				// Only add UUID import if using a custom parser, not built-in parser
				if resolvedType == "uuid.UUID" {
					if parser, exists := g.parserRegistry.GetParser(param.Type); exists {
						// Only set hasUUIDParams if this is a custom parser, not built-in
						if parser.PackagePath != "builtin" {
							hasUUIDParams = true
						}
					} else {
						// If no parser found, assume it needs the import (fallback)
						hasUUIDParams = true
					}
				}
				
				// Only analyze path parameters for parser imports
				if param.Source == models.ParameterSourcePath {
					// Check if this parameter uses a custom parser
					if parser, exists := g.parserRegistry.GetParser(param.Type); exists {
						// Add parser import if it's not a built-in parser
						if parser.PackagePath != "builtin" && parser.PackagePath != "" {
							hasCustomParsers = true
							
							// Resolve import path from package path
							importPath := g.resolvePackageImportPath(moduleName, metadata.PackagePath, filepath.Base(parser.PackagePath))
							
							// Check if this is a third-party import (contains github.com, etc.)
							if strings.Contains(importPath, "github.com") || strings.Contains(importPath, "golang.org") || strings.Contains(importPath, "gopkg.in") {
								// Add to third-party imports, avoiding duplicates
								found := false
								for _, existing := range analysis.ThirdParty {
									if existing == importPath {
										found = true
										break
									}
								}
								if !found {
									analysis.ThirdParty = append(analysis.ThirdParty, importPath)
								}
							} else {
								// For local parser packages, use the import path directly
								if !addedPaths[importPath] {
									analysis.Local = append(analysis.Local, ImportSpec{
										Alias: "", // No alias for parsers
										Path:  importPath,
									})
									addedPaths[importPath] = true
								}
							}
						}
					}
				}
				
				// Analyze all parameter types for model imports (path, body, etc.)
				// Skip built-in parser types since they use axon.ParseXXX functions
				if param.Source == models.ParameterSourcePath {
					if parser, exists := g.parserRegistry.GetParser(param.Type); exists && parser.PackagePath == "builtin" {
						// Skip import analysis for built-in parser types
						continue
					}
				}
				
				if packageName := g.extractPackageFromType(resolvedType); packageName != "" {
					// Skip well-known packages that are already imported
					if !g.isWellKnownPackage(packageName) {
						modelPackages[packageName] = true
					}
				}
			}
		}
	}
	
	// Add fmt import only if custom parsers are used (for error formatting)
	if hasCustomParsers {
		analysis.StandardLibrary = append(analysis.StandardLibrary, "fmt")
	}
	
	// Add UUID import if needed
	if hasUUIDParams {
		analysis.ThirdParty = append(analysis.ThirdParty, "github.com/google/uuid")
	}
	
	// Analyze middleware dependencies
	middlewarePackages := make(map[string]bool)
	middlewares := g.collectMiddlewareDependencies(metadata)
	if len(middlewares) > 0 {
		middlewarePackages["middleware"] = true
	}
	
	// Resolve import paths for detected packages
	
	for pkg := range servicePackages {
		importPath := g.resolvePackageImportPath(moduleName, metadata.PackagePath, pkg)
		if !addedPaths[importPath] {
			analysis.Local = append(analysis.Local, ImportSpec{
				Alias: "", // No alias for services
				Path:  importPath,
			})
			addedPaths[importPath] = true
		}
	}
	
	for pkg := range modelPackages {
		importPath := g.resolvePackageImportPath(moduleName, metadata.PackagePath, pkg)
		if !addedPaths[importPath] {
			analysis.Local = append(analysis.Local, ImportSpec{
				Alias: "", // No alias for models
				Path:  importPath,
			})
			addedPaths[importPath] = true
		}
	}
	
	for pkg := range parserPackages {
		importPath := g.resolvePackageImportPath(moduleName, metadata.PackagePath, pkg)
		if !addedPaths[importPath] {
			analysis.Local = append(analysis.Local, ImportSpec{
				Alias: "", // No alias for parsers
				Path:  importPath,
			})
			addedPaths[importPath] = true
		}
	}
	
	for pkg := range middlewarePackages {
		importPath := g.resolvePackageImportPath(moduleName, metadata.PackagePath, pkg)
		if !addedPaths[importPath] {
			analysis.Local = append(analysis.Local, ImportSpec{
				Alias: pkg, // Use package name as alias
				Path:  importPath,
			})
			addedPaths[importPath] = true
		}
		
		// Add type aliases for middleware types
		for _, middleware := range middlewares {
			analysis.TypeAliases[middleware] = fmt.Sprintf("%s.%s", pkg, middleware)
		}
	}
	
	return analysis
}

// extractPackageFromType extracts the package name from a type string like "*services.DatabaseService"
func (g *Generator) extractPackageFromType(typeStr string) string {
	// Handle function types by extracting packages from return types
	if strings.HasPrefix(typeStr, "func(") {
		// Find the return type part after the closing parenthesis
		if parenIndex := strings.Index(typeStr, ")"); parenIndex != -1 {
			returnPart := strings.TrimSpace(typeStr[parenIndex+1:])
			if returnPart != "" {
				// Recursively extract package from return type
				return g.extractPackageFromType(returnPart)
			}
		}
		return ""
	}
	
	// Remove pointer prefix
	typeStr = strings.TrimPrefix(typeStr, "*")
	
	// Check if it contains a package qualifier
	if dotIndex := strings.Index(typeStr, "."); dotIndex != -1 {
		return typeStr[:dotIndex]
	}
	
	return ""
}

// isWellKnownPackage checks if a package is already imported or is a well-known package
func (g *Generator) isWellKnownPackage(packageName string) bool {
	wellKnownPackages := map[string]bool{
		"echo":    true, // github.com/labstack/echo/v4
		"http":    true, // net/http
		"context": true, // context
		"fmt":     true, // fmt
		"errors":  true, // errors
		"uuid":    true, // github.com/google/uuid (already imported in controller)
	}
	
	return wellKnownPackages[packageName]
}

// resolvePackageImportPath resolves the import path for a package relative to the current package
func (g *Generator) resolvePackageImportPath(moduleName, currentPackagePath, targetPackage string) string {
	if g.moduleResolver != nil && moduleName != "" {
		// Use the module resolver to build the proper package path
		// Construct the target package directory path
		// This assumes the target package is a sibling of the current package
		baseDir := filepath.Dir(currentPackagePath)
		targetPackageDir := filepath.Join(baseDir, targetPackage)
		
		// Use the module resolver to build the import path
		if importPath, err := g.moduleResolver.BuildPackagePath(moduleName, targetPackageDir); err == nil {
			return importPath
		}
		
		// If BuildPackagePath fails, try to construct the path manually
		// Get current working directory
		if currentDir, err := os.Getwd(); err == nil {
			// Calculate relative path from current directory to target package
			if relPath, err := filepath.Rel(currentDir, targetPackageDir); err == nil {
				// Convert to import path format
				importPath := filepath.ToSlash(relPath)
				if importPath != "." {
					return fmt.Sprintf("%s/%s", moduleName, importPath)
				}
				return moduleName
			}
		}
	}
	
	// Final fallback to standard internal structure
	if moduleName != "" {
		return fmt.Sprintf("%s/internal/%s", moduleName, targetPackage)
	}
	
	// Fallback to relative import
	return fmt.Sprintf("../%s", targetPackage)
}

// generateRouteRegistrationFunction generates a function that registers all routes with Echo
func (g *Generator) generateRouteRegistrationFunction(metadata *models.PackageMetadata) (string, error) {
	var funcBuilder strings.Builder

	// Collect all middleware dependencies
	middlewareDeps := g.collectMiddlewareDependencies(metadata)

	// Generate function signature
	funcBuilder.WriteString("// RegisterRoutes registers all HTTP routes with the Echo instance\n")
	funcBuilder.WriteString("func RegisterRoutes(e *echo.Echo")

	// Add controller parameters
	for _, controller := range metadata.Controllers {
		funcBuilder.WriteString(fmt.Sprintf(", %s *%s", 
			strings.ToLower(controller.StructName), 
			controller.StructName))
	}

	// Add middleware parameters
	for _, middleware := range middlewareDeps {
		funcBuilder.WriteString(fmt.Sprintf(", %s *%s", 
			strings.ToLower(middleware), 
			middleware))
	}

	funcBuilder.WriteString(") {\n")

	// Generate route registrations
	for _, controller := range metadata.Controllers {
		controllerVar := strings.ToLower(controller.StructName)
		for _, route := range controller.Routes {
			registration, err := templates.GenerateRouteRegistration(route, controller.StructName, route.Middlewares)
			if err != nil {
				return "", fmt.Errorf("failed to generate registration for route %s: %w", route.HandlerName, err)
			}
			// Replace PACKAGE_NAME placeholder with actual package name
			registration = strings.ReplaceAll(registration, "PACKAGE_NAME", metadata.PackageName)
			// Replace the controller variable name in the function call
			registration = strings.ReplaceAll(registration, fmt.Sprintf("(%s", controller.StructName), fmt.Sprintf("(%s", controllerVar))
			funcBuilder.WriteString(fmt.Sprintf("\t%s\n", registration))
		}
	}

	funcBuilder.WriteString("}")

	return funcBuilder.String(), nil
}

// collectMiddlewareDependencies collects all unique middleware names used across routes
func (g *Generator) collectMiddlewareDependencies(metadata *models.PackageMetadata) []string {
	middlewareSet := make(map[string]bool)
	
	for _, controller := range metadata.Controllers {
		for _, route := range controller.Routes {
			for _, middleware := range route.Middlewares {
				middlewareSet[middleware] = true
			}
		}
	}

	var middlewares []string
	for middleware := range middlewareSet {
		middlewares = append(middlewares, middleware)
	}

	return middlewares
}

// generateControllerModuleVariable generates the FX module variable for controllers
func (g *Generator) generateControllerModuleVariable(metadata *models.PackageMetadata) string {
	var moduleBuilder strings.Builder

	moduleBuilder.WriteString("// AutogenModule provides all controllers and route registration in this package\n")
	moduleBuilder.WriteString("var AutogenModule = fx.Module(\"")
	moduleBuilder.WriteString(metadata.PackageName)
	moduleBuilder.WriteString("\",\n")

	// Add controller providers
	for _, controller := range metadata.Controllers {
		moduleBuilder.WriteString(fmt.Sprintf("\tfx.Provide(New%s),\n", controller.StructName))
	}

	// Add route registration as an invoke
	moduleBuilder.WriteString("\tfx.Invoke(RegisterRoutes),\n")

	moduleBuilder.WriteString(")\n")

	return moduleBuilder.String()
}

// generateMiddlewareModule generates a module file for packages with middleware
func (g *Generator) generateMiddlewareModule(metadata *models.PackageMetadata) (string, error) {
	var moduleBuilder strings.Builder

	// Generate package declaration with DO NOT EDIT header
	moduleBuilder.WriteString("// Code generated by Axon framework. DO NOT EDIT.\n")
	moduleBuilder.WriteString("// This file was automatically generated and should not be modified manually.\n\n")
	moduleBuilder.WriteString(fmt.Sprintf("package %s\n\n", metadata.PackageName))

	// Generate imports
	moduleBuilder.WriteString("import (\n")
	moduleBuilder.WriteString("\t\"go.uber.org/fx\"\n")
	moduleBuilder.WriteString("\t\"github.com/toyz/axon/pkg/axon\"\n")
	moduleBuilder.WriteString(")\n\n")

	// Generate middleware providers
	for _, middleware := range metadata.Middlewares {
		providerCode, err := g.generateMiddlewareProvider(middleware)
		if err != nil {
			return "", fmt.Errorf("failed to generate provider for middleware %s: %w", middleware.Name, err)
		}
		moduleBuilder.WriteString(providerCode)
		moduleBuilder.WriteString("\n")
	}

	// Generate middleware registration function
	registrationCode := g.generateMiddlewareRegistration(metadata.Middlewares)
	moduleBuilder.WriteString(registrationCode)
	moduleBuilder.WriteString("\n")

	// Generate module variable
	moduleVar := g.generateMiddlewareModuleVariable(metadata)
	moduleBuilder.WriteString(moduleVar)

	return moduleBuilder.String(), nil
}

// generateMiddlewareProvider generates a provider function for a middleware
func (g *Generator) generateMiddlewareProvider(middleware models.MiddlewareMetadata) (string, error) {
	// Use FX provider template for middleware (they all use fx.In)
	data := templates.CoreServiceProviderData{
		StructName:   middleware.StructName,
		Dependencies: []templates.DependencyData{},
		HasStart:     false,
		HasStop:      false,
	}
	return templates.ExecuteTemplate("fx-middleware-provider", templates.FXProviderTemplate, data)
}

// generateMiddlewareRegistration generates the middleware registration function
func (g *Generator) generateMiddlewareRegistration(middlewares []models.MiddlewareMetadata) string {
	var regBuilder strings.Builder

	regBuilder.WriteString("func RegisterMiddlewares(")
	
	// Add parameters for each middleware
	for i, middleware := range middlewares {
		if i > 0 {
			regBuilder.WriteString(", ")
		}
		regBuilder.WriteString(fmt.Sprintf("%s *%s", strings.ToLower(middleware.StructName), middleware.StructName))
	}
	regBuilder.WriteString(") {\n")

	// Register each middleware with the axon registry
	for _, middleware := range middlewares {
		regBuilder.WriteString(fmt.Sprintf("\taxon.RegisterMiddleware(\"%s\", %s.Handle, %s)\n", 
			middleware.Name, 
			strings.ToLower(middleware.StructName),
			strings.ToLower(middleware.StructName)))
	}

	regBuilder.WriteString("}\n")

	return regBuilder.String()
}

// generateMiddlewareModuleVariable generates the FX module variable for middleware
func (g *Generator) generateMiddlewareModuleVariable(metadata *models.PackageMetadata) string {
	var moduleBuilder strings.Builder

	moduleBuilder.WriteString("// AutogenModule provides all middleware in this package\n")
	moduleBuilder.WriteString("var AutogenModule = fx.Module(\"")
	moduleBuilder.WriteString(metadata.PackageName)
	moduleBuilder.WriteString("\",\n")

	// Add middleware providers
	for _, middleware := range metadata.Middlewares {
		moduleBuilder.WriteString(fmt.Sprintf("\tfx.Provide(New%s),\n", middleware.StructName))
	}

	// Add middleware registration as an invoke
	moduleBuilder.WriteString("\tfx.Invoke(RegisterMiddlewares),\n")

	moduleBuilder.WriteString(")\n")

	return moduleBuilder.String()
}

// generateEmptyModule generates an empty module for packages with no annotations
func (g *Generator) generateEmptyModule(metadata *models.PackageMetadata) string {
	return fmt.Sprintf(`// Code generated by Axon framework. DO NOT EDIT.
// This file was automatically generated and should not be modified manually.

package %s

import "go.uber.org/fx"

// AutogenModule provides an empty module for this package
var AutogenModule = fx.Module("%s")
`, metadata.PackageName, metadata.PackageName)
}

// extractProviders extracts provider information from package metadata
func (g *Generator) extractProviders(metadata *models.PackageMetadata) []models.Provider {
	var providers []models.Provider

	// Add controller providers
	for _, controller := range metadata.Controllers {
		providers = append(providers, models.Provider{
			Name:         fmt.Sprintf("New%s", controller.StructName),
			StructName:   controller.StructName,
			Dependencies: controller.Dependencies,
			IsLifecycle:  false,
		})
	}

	// Add core service providers
	for _, service := range metadata.CoreServices {
		if !service.IsManual {
			providers = append(providers, models.Provider{
				Name:         fmt.Sprintf("New%s", service.StructName),
				StructName:   service.StructName,
				Dependencies: service.Dependencies,
				IsLifecycle:  service.HasLifecycle,
			})
		}
	}

	// Add interface providers
	for _, iface := range metadata.Interfaces {
		providers = append(providers, models.Provider{
			Name:         fmt.Sprintf("New%s", iface.Name),
			StructName:   iface.StructName,
			Dependencies: []models.Dependency{{Name: "impl", Type: fmt.Sprintf("*%s", iface.StructName)}},
			IsLifecycle:  false,
		})
	}

	return providers
}



// GenerateRootModule generates an autogen_root_module.go file that combines sub-package modules
func (g *Generator) GenerateRootModule(packageName string, subModules []models.ModuleReference, outputPath string) error {
	if len(subModules) == 0 {
		return fmt.Errorf("no sub-modules provided for root module generation")
	}

	var rootBuilder strings.Builder

	// Generate package declaration
	rootBuilder.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Generate imports
	rootBuilder.WriteString("import (\n")
	rootBuilder.WriteString("\t\"go.uber.org/fx\"\n")

	// Add imports for all sub-module packages
	for _, module := range subModules {
		if module.PackagePath != "" {
			rootBuilder.WriteString(fmt.Sprintf("\t\"%s\"\n", module.PackagePath))
		}
	}

	rootBuilder.WriteString(")\n\n")

	// Generate root module variable
	rootBuilder.WriteString("// AutogenRootModule combines all sub-package modules\n")
	rootBuilder.WriteString(fmt.Sprintf("var AutogenRootModule = fx.Module(\"%s\",\n", packageName))

	// Add all sub-modules
	for _, module := range subModules {
		if module.PackageName != "" && module.ModuleName != "" {
			rootBuilder.WriteString(fmt.Sprintf("\t%s.%s,\n", module.PackageName, module.ModuleName))
		}
	}

	rootBuilder.WriteString(")\n")

	// Write the file
	err := os.MkdirAll(filepath.Dir(outputPath), 0755)
	if err != nil {
		return fmt.Errorf("failed to create directory for root module file: %w", err)
	}

	err = os.WriteFile(outputPath, []byte(rootBuilder.String()), 0644)
	if err != nil {
		return fmt.Errorf("failed to write root module file: %w", err)
	}

	return nil
}

// extractDependencyName extracts a variable name from a dependency type
func extractDependencyName(depType string) string {
	// Remove pointer prefix
	name := strings.TrimPrefix(depType, "*")
	
	// Handle package-qualified types (e.g., "pkg.Type" -> "type")
	if dotIndex := strings.LastIndex(name, "."); dotIndex != -1 {
		name = name[dotIndex+1:]
	}
	
	// Keep the original case for field names - Go struct fields are exported (PascalCase)
	return name
}

// GetParserRegistry returns the parser registry for cross-package parser discovery
func (g *Generator) GetParserRegistry() ParserRegistryInterface {
	return g.parserRegistry
}