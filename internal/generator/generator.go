package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/toyz/axon/internal/models"
	"github.com/toyz/axon/internal/registry"
	"github.com/toyz/axon/internal/templates"
	"github.com/toyz/axon/internal/utils"
	"github.com/toyz/axon/pkg/axon"
)

// ParserRegistryInterface defines the interface for parser registry operations
type ParserRegistryInterface interface {
	RegisterParser(parser axon.RouteParserMetadata) error
	GetParser(typeName string) (axon.RouteParserMetadata, bool)
	ListParsers() []string
	HasParser(typeName string) bool
	Clear()
	ClearCustomParsers()
	GetAllParsers() map[string]axon.RouteParserMetadata
}

// Generator implements the CodeGenerator interface
type Generator struct {
	moduleResolver ModuleResolver
	parserRegistry ParserRegistryInterface
}

// ModuleResolver interface for resolving module paths
type ModuleResolver interface {
	ResolveModuleName(customName string) (string, error)
	BuildPackagePath(moduleName, packageDir string) (string, error)
}

// NewGenerator creates a new code generator instance
func NewGenerator() *Generator {
	return &Generator{
		parserRegistry: registry.NewParserRegistry(),
	}
}

// NewGeneratorWithResolver creates a new code generator instance with a module resolver
func NewGeneratorWithResolver(resolver ModuleResolver) *Generator {
	return &Generator{
		moduleResolver: resolver,
		parserRegistry: registry.NewParserRegistry(),
	}
}

// GenerateModule generates a complete FX module file for a package with annotations
func (g *Generator) GenerateModule(metadata *models.PackageMetadata) (*models.GeneratedModule, error) {
	return g.GenerateModuleWithModule(metadata, "")
}

// GenerateModuleWithModule generates a complete FX module file for a package with annotations and module name
func (g *Generator) GenerateModuleWithModule(metadata *models.PackageMetadata, moduleName string) (*models.GeneratedModule, error) {
	return g.GenerateModuleWithPackagePaths(metadata, moduleName, nil)
}

// GenerateModuleWithPackagePaths generates a complete FX module file with package path mappings
func (g *Generator) GenerateModuleWithPackagePaths(metadata *models.PackageMetadata, moduleName string, packagePaths map[string]string) (*models.GeneratedModule, error) {
	if metadata == nil {
		return nil, fmt.Errorf("metadata cannot be nil")
	}

	// Determine the output file path
	filePath := filepath.Join(metadata.PackagePath, "autogen_module.go")

	// Generate the module content based on what annotations are present
	var content string
	var err error

	if len(metadata.Controllers) > 0 {
		// Generate controller module
		content, err = g.generateControllerModuleWithModule(metadata, moduleName)
	} else if len(metadata.Middlewares) > 0 {
		// Generate middleware module
		content, err = g.generateMiddlewareModule(metadata)
	} else if len(metadata.CoreServices) > 0 || len(metadata.Interfaces) > 0 || len(metadata.Loggers) > 0 {
		// Generate core services module (includes loggers)
		content, err = templates.GenerateCoreServiceModuleWithResolver(metadata, moduleName, packagePaths)
	} else {
		// Empty module
		content = g.generateEmptyModule(metadata)
	}

	if err != nil {
		return nil, fmt.Errorf("failed to generate module content: %w", err)
	}

	// Extract providers from the metadata
	providers := g.extractProviders(metadata)

	return &models.GeneratedModule{
		PackageName: metadata.PackageName,
		FilePath:    filePath,
		Content:     content,
		Providers:   providers,
	}, nil
}

// generateControllerModule generates a module file for packages with controllers
func (g *Generator) generateControllerModule(metadata *models.PackageMetadata) (string, error) {
	return g.generateControllerModuleWithModule(metadata, "")
}

// generateControllerModuleWithModule generates a module file for packages with controllers with module name
func (g *Generator) generateControllerModuleWithModule(metadata *models.PackageMetadata, moduleName string) (string, error) {
	var moduleBuilder strings.Builder

	// Generate package declaration with DO NOT EDIT header
	moduleBuilder.WriteString("// Code generated by Axon framework. DO NOT EDIT.\n")
	moduleBuilder.WriteString("// This file was automatically generated and should not be modified manually.\n\n")
	moduleBuilder.WriteString(fmt.Sprintf("package %s\n\n", metadata.PackageName))

	// Analyze what imports are needed by examining the metadata
	imports := g.analyzeRequiredImports(metadata, moduleName)

	// Generate imports
	moduleBuilder.WriteString("import (\n")

	// Standard library imports first
	for _, imp := range imports.StandardLibrary {
		moduleBuilder.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
	}

	if len(imports.StandardLibrary) > 0 && (len(imports.ThirdParty) > 0 || len(imports.Local) > 0) {
		moduleBuilder.WriteString("\n")
	}

	// Third party imports
	for _, imp := range imports.ThirdParty {
		moduleBuilder.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
	}

	if len(imports.ThirdParty) > 0 && len(imports.Local) > 0 {
		moduleBuilder.WriteString("\n")
	}

	// Local imports with aliases
	for _, importSpec := range imports.Local {
		if importSpec.Alias != "" {
			moduleBuilder.WriteString(fmt.Sprintf("\t%s \"%s\"\n", importSpec.Alias, importSpec.Path))
		} else {
			moduleBuilder.WriteString(fmt.Sprintf("\t\"%s\"\n", importSpec.Path))
		}
	}

	moduleBuilder.WriteString(")\n\n")

	// Add type aliases for imported types if needed
	for alias, typeName := range imports.TypeAliases {
		moduleBuilder.WriteString(fmt.Sprintf("type %s = %s\n", alias, typeName))
	}
	if len(imports.TypeAliases) > 0 {
		moduleBuilder.WriteString("\n")
	}

	// Generate shared helper functions for response handling
	if len(metadata.Controllers) > 0 {
		helperFunctions := g.generateResponseHelperFunctions()
		moduleBuilder.WriteString(helperFunctions)
		moduleBuilder.WriteString("\n\n")
	}

	// Generate controller providers
	for _, controller := range metadata.Controllers {
		providerCode, err := g.generateControllerProvider(controller)
		if err != nil {
			return "", fmt.Errorf("failed to generate provider for controller %s: %w", controller.Name, err)
		}
		moduleBuilder.WriteString(providerCode)
		moduleBuilder.WriteString("\n\n")
	}

	// Generate route wrapper functions
	for _, controller := range metadata.Controllers {
		for _, route := range controller.Routes {
			wrapperCode, err := templates.GenerateRouteWrapper(route, controller.StructName, g.parserRegistry)
			if err != nil {
				return "", fmt.Errorf("failed to generate wrapper for route %s.%s: %w", controller.Name, route.HandlerName, err)
			}
			moduleBuilder.WriteString(wrapperCode)
			moduleBuilder.WriteString("\n\n")
		}
	}

	// Generate route registration function
	registrationCode, err := g.generateRouteRegistrationFunction(metadata)
	if err != nil {
		return "", fmt.Errorf("failed to generate route registration function: %w", err)
	}
	moduleBuilder.WriteString(registrationCode)
	moduleBuilder.WriteString("\n\n")

	// Generate module variable
	moduleCode := g.generateControllerModuleVariable(metadata)
	moduleBuilder.WriteString(moduleCode)

	return moduleBuilder.String(), nil
}

// generateControllerProvider generates an FX provider for a controller
func (g *Generator) generateControllerProvider(controller models.ControllerMetadata) (string, error) {
	// Convert dependencies to template data
	var deps []templates.DependencyData
	var injectedDeps []templates.DependencyData

	for _, dep := range controller.Dependencies {
		// Use the actual field name, converted to camelCase for parameter
		paramName := strings.ToLower(dep.Name[:1]) + dep.Name[1:]
		depData := templates.DependencyData{
			Name:      paramName,
			FieldName: dep.Name,
			Type:      dep.Type,
			IsInit:    dep.IsInit,
		}
		deps = append(deps, depData)

		// Only add to injected deps if it's not an init dependency
		if !dep.IsInit {
			injectedDeps = append(injectedDeps, depData)
		}
	}

	data := templates.CoreServiceProviderData{
		StructName:   controller.StructName,
		Dependencies: deps,
		InjectedDeps: injectedDeps,
		HasStart:     false,
		HasStop:      false,
	}

	return templates.ExecuteTemplate("controller-provider", templates.ProviderTemplate, data)
}

// ImportAnalysis represents the analyzed imports needed for code generation
type ImportAnalysis struct {
	StandardLibrary []string          // Standard library imports like "net/http"
	ThirdParty      []string          // Third party imports like "github.com/labstack/echo/v4"
	Local           []ImportSpec      // Local imports with optional aliases
	TypeAliases     map[string]string // Type aliases: alias -> full type name
}

// ImportSpec represents an import specification
type ImportSpec struct {
	Alias string // Optional alias, empty string means no alias
	Path  string // Import path
}

// analyzeRequiredImports analyzes the metadata to determine what imports are needed
func (g *Generator) analyzeRequiredImports(metadata *models.PackageMetadata, moduleName string) ImportAnalysis {
	analysis := ImportAnalysis{
		StandardLibrary: []string{},
		ThirdParty:      []string{},
		Local:           []ImportSpec{},
		TypeAliases:     make(map[string]string),
	}

	// Always needed for controllers
	analysis.StandardLibrary = append(analysis.StandardLibrary, "net/http")
	analysis.ThirdParty = append(analysis.ThirdParty,
		"github.com/labstack/echo/v4",
		"go.uber.org/fx",
		"github.com/toyz/axon/pkg/axon")

	// Analyze controller dependencies for service imports
	servicePackages := make(map[string]bool)
	for _, controller := range metadata.Controllers {
		for _, dep := range controller.Dependencies {
			if packageName := g.extractPackageFromType(dep.Type); packageName != "" {
				servicePackages[packageName] = true
			}
		}
	}

	// Analyze route parameters for model imports and parser imports
	modelPackages := make(map[string]bool)
	parserPackages := make(map[string]bool)
	hasUUIDParams := false
	hasCustomParsers := false
	addedPaths := make(map[string]bool) // Track added paths to avoid duplicates
	for _, controller := range metadata.Controllers {
		for _, route := range controller.Routes {
			for _, param := range route.Parameters {
				// Resolve type alias to check for imports
				resolvedType := axon.ResolveTypeAlias(param.Type)

				// Check for UUID parameters (including alias)
				// Only add UUID import if using a custom parser, not built-in parser
				if resolvedType == "uuid.UUID" {
					if parser, exists := g.parserRegistry.GetParser(param.Type); exists {
						// Only set hasUUIDParams if this is a custom parser, not built-in
						if parser.PackagePath != "builtin" {
							hasUUIDParams = true
						}
					} else {
						// If no parser found, assume it needs the import (fallback)
						hasUUIDParams = true
					}
				}

				// Only analyze path parameters for parser imports
				if param.Source == models.ParameterSourcePath {
					// Check if ParserFunc references a custom parser package
					if param.ParserFunc != "" && strings.Contains(param.ParserFunc, "parsers.") {
						hasCustomParsers = true
						// Add parsers package import (avoid duplicates)
						importPath := g.resolvePackageImportPath(moduleName, metadata.PackagePath, "parsers")
						found := false
						for _, existing := range analysis.Local {
							if existing.Path == importPath {
								found = true
								break
							}
						}
						if !found {
							analysis.Local = append(analysis.Local, ImportSpec{Path: importPath})
						}
					} else if parser, exists := g.parserRegistry.GetParser(param.Type); exists {
						// Add parser import if it's not a built-in parser
						if parser.PackagePath != "builtin" && parser.PackagePath != "" {
							hasCustomParsers = true

							// Resolve import path from package path
							importPath := g.resolvePackageImportPath(moduleName, metadata.PackagePath, filepath.Base(parser.PackagePath))

							// Check if this is a third-party import (contains github.com, etc.)
							if strings.Contains(importPath, "github.com") || strings.Contains(importPath, "golang.org") || strings.Contains(importPath, "gopkg.in") {
								// Add to third-party imports, avoiding duplicates
								found := false
								for _, existing := range analysis.ThirdParty {
									if existing == importPath {
										found = true
										break
									}
								}
								if !found {
									analysis.ThirdParty = append(analysis.ThirdParty, importPath)
								}
							} else {
								// For local parser packages, use the import path directly
								if !addedPaths[importPath] {
									analysis.Local = append(analysis.Local, ImportSpec{
										Alias: "", // No alias for parsers
										Path:  importPath,
									})
									addedPaths[importPath] = true
								}
							}
						}
					}
				}

				// Analyze all parameter types for model imports (path, body, etc.)
				// Skip built-in parser types since they use axon.ParseXXX functions
				if param.Source == models.ParameterSourcePath {
					if parser, exists := g.parserRegistry.GetParser(param.Type); exists && parser.PackagePath == "builtin" {
						// Skip import analysis for built-in parser types
						continue
					}
				}

				if packageName := g.extractPackageFromType(resolvedType); packageName != "" {
					// Skip well-known packages that are already imported
					if !g.isWellKnownPackage(packageName) {
						modelPackages[packageName] = true
					}
				}
			}
		}
	}

	// Add fmt import if custom parsers are used (for error formatting) or if controllers exist (for response handling)
	if hasCustomParsers || len(metadata.Controllers) > 0 {
		analysis.StandardLibrary = append(analysis.StandardLibrary, "fmt")
	}

	// Add UUID import if needed
	if hasUUIDParams {
		analysis.ThirdParty = append(analysis.ThirdParty, "github.com/google/uuid")
	}

	// Analyze middleware dependencies
	middlewarePackages := make(map[string]bool)
	middlewares := g.collectMiddlewareDependencies(metadata)
	if len(middlewares) > 0 {
		middlewarePackages["middleware"] = true
	}

	// Resolve import paths for detected packages

	for pkg := range servicePackages {
		importPath := g.resolvePackageImportPath(moduleName, metadata.PackagePath, pkg)
		if !addedPaths[importPath] {
			analysis.Local = append(analysis.Local, ImportSpec{
				Alias: "", // No alias for services
				Path:  importPath,
			})
			addedPaths[importPath] = true
		}
	}

	for pkg := range modelPackages {
		importPath := g.resolvePackageImportPath(moduleName, metadata.PackagePath, pkg)
		if !addedPaths[importPath] {
			analysis.Local = append(analysis.Local, ImportSpec{
				Alias: "", // No alias for models
				Path:  importPath,
			})
			addedPaths[importPath] = true
		}
	}

	for pkg := range parserPackages {
		importPath := g.resolvePackageImportPath(moduleName, metadata.PackagePath, pkg)
		if !addedPaths[importPath] {
			analysis.Local = append(analysis.Local, ImportSpec{
				Alias: "", // No alias for parsers
				Path:  importPath,
			})
			addedPaths[importPath] = true
		}
	}

	for pkg := range middlewarePackages {
		importPath := g.resolvePackageImportPath(moduleName, metadata.PackagePath, pkg)
		if !addedPaths[importPath] {
			analysis.Local = append(analysis.Local, ImportSpec{
				Alias: pkg, // Use package name as alias
				Path:  importPath,
			})
			addedPaths[importPath] = true
		}

		// Add type aliases for middleware types
		for _, middleware := range middlewares {
			analysis.TypeAliases[middleware] = fmt.Sprintf("%s.%s", pkg, middleware)
		}
	}

	return analysis
}

// extractPackageFromType extracts the package name from a type string like "*services.DatabaseService"
func (g *Generator) extractPackageFromType(typeStr string) string {
	// Handle function types by extracting packages from return types
	if strings.HasPrefix(typeStr, "func(") {
		// Find the return type part after the closing parenthesis
		if parenIndex := strings.Index(typeStr, ")"); parenIndex != -1 {
			returnPart := strings.TrimSpace(typeStr[parenIndex+1:])
			if returnPart != "" {
				// Recursively extract package from return type
				return g.extractPackageFromType(returnPart)
			}
		}
		return ""
	}

	// Remove pointer prefix
	typeStr = strings.TrimPrefix(typeStr, "*")

	// Check if it contains a package qualifier
	if dotIndex := strings.Index(typeStr, "."); dotIndex != -1 {
		return typeStr[:dotIndex]
	}

	return ""
}

// isWellKnownPackage checks if a package is already imported or is a well-known package
func (g *Generator) isWellKnownPackage(packageName string) bool {
	wellKnownPackages := map[string]bool{
		"echo":    true, // github.com/labstack/echo/v4
		"http":    true, // net/http
		"context": true, // context
		"fmt":     true, // fmt
		"errors":  true, // errors
		"uuid":    true, // github.com/google/uuid (already imported in controller)
		"axon":    true, // github.com/toyz/axon/pkg/axon (already imported)
	}

	return wellKnownPackages[packageName]
}

// resolvePackageImportPath resolves the import path for a package relative to the current package
func (g *Generator) resolvePackageImportPath(moduleName, currentPackagePath, targetPackage string) string {
	if g.moduleResolver != nil && moduleName != "" {
		// Use the module resolver to build the proper package path
		// Construct the target package directory path
		// This assumes the target package is a sibling of the current package
		baseDir := filepath.Dir(currentPackagePath)
		targetPackageDir := filepath.Join(baseDir, targetPackage)

		// Use the module resolver to build the import path
		if importPath, err := g.moduleResolver.BuildPackagePath(moduleName, targetPackageDir); err == nil {
			return importPath
		}

		// If BuildPackagePath fails, try to construct the path manually
		// Get current working directory
		if currentDir, err := os.Getwd(); err == nil {
			// Calculate relative path from current directory to target package
			if relPath, err := filepath.Rel(currentDir, targetPackageDir); err == nil {
				// Convert to import path format
				importPath := filepath.ToSlash(relPath)
				if importPath != "." {
					return fmt.Sprintf("%s/%s", moduleName, importPath)
				}
				return moduleName
			}
		}
	}

	// Final fallback to standard internal structure
	if moduleName != "" {
		return fmt.Sprintf("%s/internal/%s", moduleName, targetPackage)
	}

	// If moduleName is empty, try to detect it from the current working directory
	if cwd, err := os.Getwd(); err == nil {
		if goModPath := filepath.Join(cwd, "go.mod"); fileExists(goModPath) {
			if detectedModule := extractModuleNameFromGoMod(goModPath); detectedModule != "" {
				return fmt.Sprintf("%s/internal/%s", detectedModule, targetPackage)
			}
		}
	}

	// Last resort: use a reasonable default module path instead of relative imports
	// This avoids the "relative import paths are not supported in module mode" error
	return fmt.Sprintf("testmodule/%s", targetPackage)
}

// fileExists checks if a file exists
func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

// extractModuleNameFromGoMod extracts the module name from a go.mod file using the shared utility
func extractModuleNameFromGoMod(goModPath string) string {
	fileReader := utils.NewFileReader()
	goModParser := utils.NewGoModParser(fileReader)
	
	moduleName, err := goModParser.ParseModuleName(goModPath)
	if err != nil {
		return ""
	}
	return moduleName
}

// analyzeMiddlewareImports analyzes imports needed for middleware module generation
func (g *Generator) analyzeMiddlewareImports(metadata *models.PackageMetadata) ImportAnalysis {
	analysis := ImportAnalysis{
		StandardLibrary: []string{},
		ThirdParty:      []string{},
		Local:           []ImportSpec{},
		TypeAliases:     make(map[string]string),
	}

	// Always needed for middleware modules
	analysis.ThirdParty = append(analysis.ThirdParty,
		"go.uber.org/fx",
		"github.com/toyz/axon/pkg/axon")

	// Analyze middleware dependencies for service imports
	addedPaths := make(map[string]bool) // Track added paths to avoid duplicates
	for _, middleware := range metadata.Middlewares {
		for _, dep := range middleware.Dependencies {
			if packageName := g.extractPackageFromType(dep.Type); packageName != "" {
				// Skip well-known packages that are already imported
				if !g.isWellKnownPackage(packageName) {
					// Resolve import path for the dependency package
					importPath := g.resolvePackageImportPath("", metadata.PackagePath, packageName)
					if !addedPaths[importPath] {
						analysis.Local = append(analysis.Local, ImportSpec{
							Alias: "", // No alias for dependencies
							Path:  importPath,
						})
						addedPaths[importPath] = true
					}
				}
			}
		}
	}

	return analysis
}

// generateRouteRegistrationFunction generates a function that registers all routes with Echo
func (g *Generator) generateRouteRegistrationFunction(metadata *models.PackageMetadata) (string, error) {
	var funcBuilder strings.Builder

	// Collect all middleware dependencies
	middlewareDeps := g.collectMiddlewareDependencies(metadata)

	// Generate function signature
	funcBuilder.WriteString("// RegisterRoutes registers all HTTP routes with the Echo instance\n")
	funcBuilder.WriteString("func RegisterRoutes(e *echo.Echo")

	// Add controller parameters
	for _, controller := range metadata.Controllers {
		funcBuilder.WriteString(fmt.Sprintf(", %s *%s",
			strings.ToLower(controller.StructName),
			controller.StructName))
	}

	// Add middleware parameters
	for _, middleware := range middlewareDeps {
		funcBuilder.WriteString(fmt.Sprintf(", %s *%s",
			strings.ToLower(middleware),
			middleware))
	}

	funcBuilder.WriteString(") {\n")

	// Generate route registrations - group by controller
	for _, controller := range metadata.Controllers {
		controllerVar := strings.ToLower(controller.StructName)
		
		// If controller has prefix and/or middleware, use Echo group
		if controller.Prefix != "" || len(controller.Middlewares) > 0 {
			// Create Echo group
			groupVar := fmt.Sprintf("%sGroup", controllerVar)
			
			if controller.Prefix != "" {
				// Convert Axon path format to Echo format for group
				echoPrefix := g.convertToEchoPath(controller.Prefix)
				funcBuilder.WriteString(fmt.Sprintf("\t%s := e.Group(\"%s\")\n", groupVar, echoPrefix))
			} else {
				funcBuilder.WriteString(fmt.Sprintf("\t%s := e.Group(\"\")\n", groupVar))
			}
			
			// Apply controller middleware to group
			for _, middlewareName := range controller.Middlewares {
				middlewareVar := strings.ToLower(middlewareName)
				funcBuilder.WriteString(fmt.Sprintf("\t%s.Use(%s.Handle)\n", groupVar, middlewareVar))
			}
			
			// Register routes on the group
			for _, route := range controller.Routes {
				registration, err := g.generateGroupRouteRegistration(route, controller, groupVar, metadata.PackageName)
				if err != nil {
					return "", fmt.Errorf("failed to generate registration for route %s: %w", route.HandlerName, err)
				}
				funcBuilder.WriteString(registration)
			}
		} else {
			// No prefix or middleware, register directly on Echo
			for _, route := range controller.Routes {
				registration, err := templates.GenerateRouteRegistration(route, controller.StructName, route.Middlewares)
				if err != nil {
					return "", fmt.Errorf("failed to generate registration for route %s: %w", route.HandlerName, err)
				}
				// Replace PACKAGE_NAME placeholder with actual package name
				registration = strings.ReplaceAll(registration, "PACKAGE_NAME", metadata.PackageName)
				// Replace the controller variable name in the function call
				registration = strings.ReplaceAll(registration, fmt.Sprintf("(%s", controller.StructName), fmt.Sprintf("(%s", controllerVar))
				funcBuilder.WriteString(fmt.Sprintf("\t%s\n", registration))
			}
		}
	}

	funcBuilder.WriteString("}")

	return funcBuilder.String(), nil
}

// collectMiddlewareDependencies collects all unique middleware names used across routes
func (g *Generator) collectMiddlewareDependencies(metadata *models.PackageMetadata) []string {
	middlewareSet := make(map[string]bool)

	for _, controller := range metadata.Controllers {
		for _, route := range controller.Routes {
			for _, middleware := range route.Middlewares {
				middlewareSet[middleware] = true
			}
		}
	}

	var middlewares []string
	for middleware := range middlewareSet {
		middlewares = append(middlewares, middleware)
	}

	return middlewares
}

// generateControllerModuleVariable generates the FX module variable for controllers
func (g *Generator) generateControllerModuleVariable(metadata *models.PackageMetadata) string {
	var moduleBuilder strings.Builder

	moduleBuilder.WriteString("// AutogenModule provides all controllers and route registration in this package\n")
	moduleBuilder.WriteString("var AutogenModule = fx.Module(\"")
	moduleBuilder.WriteString(metadata.PackageName)
	moduleBuilder.WriteString("\",\n")

	// Add controller providers
	for _, controller := range metadata.Controllers {
		moduleBuilder.WriteString(fmt.Sprintf("\tfx.Provide(New%s),\n", controller.StructName))
	}

	// Add route registration as an invoke
	moduleBuilder.WriteString("\tfx.Invoke(RegisterRoutes),\n")

	moduleBuilder.WriteString(")\n")

	return moduleBuilder.String()
}

// generateMiddlewareModule generates a module file for packages with middleware
func (g *Generator) generateMiddlewareModule(metadata *models.PackageMetadata) (string, error) {
	var moduleBuilder strings.Builder

	// Generate package declaration with DO NOT EDIT header
	moduleBuilder.WriteString("// Code generated by Axon framework. DO NOT EDIT.\n")
	moduleBuilder.WriteString("// This file was automatically generated and should not be modified manually.\n\n")
	moduleBuilder.WriteString(fmt.Sprintf("package %s\n\n", metadata.PackageName))

	// Analyze what imports are needed by examining middleware dependencies
	imports := g.analyzeMiddlewareImports(metadata)

	// Generate imports section
	moduleBuilder.WriteString("import (\n")

	// Add standard library imports
	for _, imp := range imports.StandardLibrary {
		moduleBuilder.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
	}

	// Add a blank line if we have both standard and third-party imports
	if len(imports.StandardLibrary) > 0 && len(imports.ThirdParty) > 0 {
		moduleBuilder.WriteString("\n")
	}

	// Add third-party imports
	for _, imp := range imports.ThirdParty {
		moduleBuilder.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
	}

	// Add a blank line if we have both third-party and local imports
	if len(imports.ThirdParty) > 0 && len(imports.Local) > 0 {
		moduleBuilder.WriteString("\n")
	}

	// Add local imports
	for _, imp := range imports.Local {
		if imp.Alias != "" {
			moduleBuilder.WriteString(fmt.Sprintf("\t%s \"%s\"\n", imp.Alias, imp.Path))
		} else {
			moduleBuilder.WriteString(fmt.Sprintf("\t\"%s\"\n", imp.Path))
		}
	}

	moduleBuilder.WriteString(")\n\n")

	// Generate middleware providers using templates
	for _, middleware := range metadata.Middlewares {
		providerCode, err := templates.GenerateMiddlewareProvider(middleware)
		if err != nil {
			return "", fmt.Errorf("failed to generate provider for middleware %s: %w", middleware.Name, err)
		}
		moduleBuilder.WriteString(providerCode)
		moduleBuilder.WriteString("\n")
	}

	// Generate middleware registration function using templates
	registrationCode, err := templates.GenerateMiddlewareRegistry(metadata.Middlewares)
	if err != nil {
		return "", fmt.Errorf("failed to generate middleware registration: %w", err)
	}
	moduleBuilder.WriteString(registrationCode)
	moduleBuilder.WriteString("\n")

	// Generate global middleware registration if there are global middlewares
	hasGlobalMiddleware := false
	for _, mw := range metadata.Middlewares {
		if mw.IsGlobal {
			hasGlobalMiddleware = true
			break
		}
	}
	
	if hasGlobalMiddleware {
		globalRegistrationCode, err := templates.GenerateGlobalMiddlewareRegistration(metadata.Middlewares)
		if err != nil {
			return "", fmt.Errorf("failed to generate global middleware registration: %w", err)
		}
		moduleBuilder.WriteString(globalRegistrationCode)
		moduleBuilder.WriteString("\n")
	}

	// Generate module variable
	moduleBuilder.WriteString("// AutogenModule provides all middleware in this package\n")
	moduleBuilder.WriteString(fmt.Sprintf("var AutogenModule = fx.Module(\"%s\",\n", metadata.PackageName))

	// Add middleware providers
	for _, middleware := range metadata.Middlewares {
		moduleBuilder.WriteString(fmt.Sprintf("\tfx.Provide(New%s),\n", middleware.StructName))
	}

	// Add middleware registration as an invoke
	moduleBuilder.WriteString("\tfx.Invoke(RegisterMiddlewares),\n")

	// Add global middleware registration if there are global middlewares
	if hasGlobalMiddleware {
		moduleBuilder.WriteString("\tfx.Invoke(RegisterGlobalMiddleware),\n")
	}

	moduleBuilder.WriteString(")\n")

	return moduleBuilder.String(), nil
}

// Removed old inline middleware generation functions - now using templates

// generateEmptyModule generates an empty module for packages with no annotations
func (g *Generator) generateEmptyModule(metadata *models.PackageMetadata) string {
	return fmt.Sprintf(`// Code generated by Axon framework. DO NOT EDIT.
// This file was automatically generated and should not be modified manually.

package %s

import "go.uber.org/fx"

// AutogenModule provides an empty module for this package
var AutogenModule = fx.Module("%s")
`, metadata.PackageName, metadata.PackageName)
}

// extractProviders extracts provider information from package metadata
func (g *Generator) extractProviders(metadata *models.PackageMetadata) []models.Provider {
	var providers []models.Provider

	// Add controller providers
	for _, controller := range metadata.Controllers {
		providers = append(providers, models.Provider{
			Name:         fmt.Sprintf("New%s", controller.StructName),
			StructName:   controller.StructName,
			Dependencies: controller.Dependencies,
			IsLifecycle:  false,
		})
	}

	// Add core service providers
	for _, service := range metadata.CoreServices {
		if !service.IsManual {
			providers = append(providers, models.Provider{
				Name:         fmt.Sprintf("New%s", service.StructName),
				StructName:   service.StructName,
				Dependencies: service.Dependencies,
				IsLifecycle:  service.HasLifecycle,
			})
		}
	}

	// Add interface providers
	for _, iface := range metadata.Interfaces {
		providers = append(providers, models.Provider{
			Name:         fmt.Sprintf("New%s", iface.Name),
			StructName:   iface.StructName,
			Dependencies: []models.Dependency{{Name: "impl", Type: fmt.Sprintf("*%s", iface.StructName)}},
			IsLifecycle:  false,
		})
	}

	return providers
}

// GenerateRootModule generates an autogen_root_module.go file that combines sub-package modules
func (g *Generator) GenerateRootModule(packageName string, subModules []models.ModuleReference, outputPath string) error {
	if len(subModules) == 0 {
		return fmt.Errorf("no sub-modules provided for root module generation")
	}

	var rootBuilder strings.Builder

	// Generate package declaration
	rootBuilder.WriteString(fmt.Sprintf("package %s\n\n", packageName))

	// Generate imports
	rootBuilder.WriteString("import (\n")
	rootBuilder.WriteString("\t\"go.uber.org/fx\"\n")

	// Add imports for all sub-module packages
	for _, module := range subModules {
		if module.PackagePath != "" {
			rootBuilder.WriteString(fmt.Sprintf("\t\"%s\"\n", module.PackagePath))
		}
	}

	rootBuilder.WriteString(")\n\n")

	// Generate root module variable
	rootBuilder.WriteString("// AutogenRootModule combines all sub-package modules\n")
	rootBuilder.WriteString(fmt.Sprintf("var AutogenRootModule = fx.Module(\"%s\",\n", packageName))

	// Add all sub-modules
	for _, module := range subModules {
		if module.PackageName != "" && module.ModuleName != "" {
			rootBuilder.WriteString(fmt.Sprintf("\t%s.%s,\n", module.PackageName, module.ModuleName))
		}
	}

	rootBuilder.WriteString(")\n")

	// Write the file
	err := os.MkdirAll(filepath.Dir(outputPath), 0755)
	if err != nil {
		return fmt.Errorf("failed to create directory for root module file: %w", err)
	}

	err = os.WriteFile(outputPath, []byte(rootBuilder.String()), 0644)
	if err != nil {
		return fmt.Errorf("failed to write root module file: %w", err)
	}

	return nil
}

// extractDependencyName extracts a variable name from a dependency type
func extractDependencyName(depType string) string {
	// Remove pointer prefix
	name := strings.TrimPrefix(depType, "*")

	// Handle package-qualified types (e.g., "pkg.Type" -> "type")
	if dotIndex := strings.LastIndex(name, "."); dotIndex != -1 {
		name = name[dotIndex+1:]
	}

	// Keep the original case for field names - Go struct fields are exported (PascalCase)
	return name
}

// generateResponseHelperFunctions generates shared helper functions for response handling
func (g *Generator) generateResponseHelperFunctions() string {
	return `// handleAxonResponse processes an axon.Response and applies headers, cookies, and content type
func handleAxonResponse(c echo.Context, response *axon.Response) error {
	// Set headers
	for key, value := range response.Headers {
		c.Response().Header().Set(key, value)
	}
	
	// Set cookies
	for _, cookie := range response.Cookies {
		httpCookie := &http.Cookie{
			Name:     cookie.Name,
			Value:    cookie.Value,
			Path:     cookie.Path,
			Domain:   cookie.Domain,
			MaxAge:   cookie.MaxAge,
			Secure:   cookie.Secure,
			HttpOnly: cookie.HttpOnly,
		}
		if cookie.SameSite != "" {
			switch cookie.SameSite {
			case "Strict":
				httpCookie.SameSite = http.SameSiteStrictMode
			case "Lax":
				httpCookie.SameSite = http.SameSiteLaxMode
			case "None":
				httpCookie.SameSite = http.SameSiteNoneMode
			}
		}
		c.SetCookie(httpCookie)
	}
	
	// Set content type and return response
	if response.ContentType != "" {
		return c.Blob(response.StatusCode, response.ContentType, []byte(fmt.Sprintf("%v", response.Body)))
	}
	return c.JSON(response.StatusCode, response.Body)
}

// handleHttpError processes an axon.HttpError and returns appropriate JSON response
func handleHttpError(c echo.Context, httpErr *axon.HttpError) error {
	return c.JSON(httpErr.StatusCode, httpErr)
}

// handleError processes any error and returns appropriate response (HttpError or generic error)
func handleError(c echo.Context, err error) error {
	if httpErr, ok := err.(*axon.HttpError); ok {
		return handleHttpError(c, httpErr)
	}
	return echo.NewHTTPError(http.StatusInternalServerError, err.Error())
}`
}

// GetParserRegistry returns the parser registry for cross-package parser discovery
func (g *Generator) GetParserRegistry() ParserRegistryInterface {
	return g.parserRegistry
}
// convertToEchoPath converts Axon path format to Echo path format
func (g *Generator) convertToEchoPath(axonPath string) string {
	// Convert {param:type} to :param
	re := regexp.MustCompile(`\{([^:}]+):[^}]+\}`)
	return re.ReplaceAllString(axonPath, ":$1")
}

// generateGroupRouteRegistration generates route registration for Echo groups
func (g *Generator) generateGroupRouteRegistration(route models.RouteMetadata, controller models.ControllerMetadata, groupVar, packageName string) (string, error) {
	var regBuilder strings.Builder
	
	controllerVar := strings.ToLower(controller.StructName)
	handlerVar := fmt.Sprintf("handler_%s%s", controllerVar, strings.ToLower(route.HandlerName))
	
	// Generate handler wrapper
	wrapperFunc := fmt.Sprintf("wrap%s%s", controller.StructName, route.HandlerName)
	
	// Determine if route has its own middleware
	if len(route.Middlewares) > 0 {
		// Route has middleware - pass middleware to wrapper
		middlewareParams := ""
		for _, mw := range route.Middlewares {
			middlewareParams += fmt.Sprintf(", %s", strings.ToLower(mw))
		}
		regBuilder.WriteString(fmt.Sprintf("\t%s := %s(%s%s)\n", handlerVar, wrapperFunc, controllerVar, middlewareParams))
	} else {
		// No route middleware
		regBuilder.WriteString(fmt.Sprintf("\t%s := %s(%s)\n", handlerVar, wrapperFunc, controllerVar))
	}
	
	// Register route on group (path is relative to group prefix)
	routePath := route.Path
	if controller.Prefix != "" {
		// Remove controller prefix from route path since group already has it
		if strings.HasPrefix(route.Path, controller.Prefix) {
			routePath = strings.TrimPrefix(route.Path, controller.Prefix)
			if routePath == "" {
				routePath = "/"
			}
		}
	}
	
	echoPath := g.convertToEchoPath(routePath)
	regBuilder.WriteString(fmt.Sprintf("\t%s.%s(\"%s\", %s)\n", groupVar, route.Method, echoPath, handlerVar))
	
	// Generate route registry registration
	regBuilder.WriteString(fmt.Sprintf("\taxon.DefaultRouteRegistry.RegisterRoute(axon.RouteInfo{\n"))
	regBuilder.WriteString(fmt.Sprintf("\t\tMethod:         \"%s\",\n", route.Method))
	regBuilder.WriteString(fmt.Sprintf("\t\tPath:           \"%s\",\n", route.Path))
	regBuilder.WriteString(fmt.Sprintf("\t\tEchoPath:       \"%s\",\n", g.convertToEchoPath(route.Path)))
	regBuilder.WriteString(fmt.Sprintf("\t\tHandlerName:    \"%s\",\n", route.HandlerName))
	regBuilder.WriteString(fmt.Sprintf("\t\tControllerName: \"%s\",\n", controller.StructName))
	regBuilder.WriteString(fmt.Sprintf("\t\tPackageName:    \"%s\",\n", packageName))
	
	// Add middleware info
	if len(route.Middlewares) > 0 {
		regBuilder.WriteString("\t\tMiddlewares:    []string{")
		for i, mw := range route.Middlewares {
			if i > 0 {
				regBuilder.WriteString(", ")
			}
			regBuilder.WriteString(fmt.Sprintf("\"%s\"", mw))
		}
		regBuilder.WriteString("},\n")
	} else {
		regBuilder.WriteString("\t\tMiddlewares:    []string{},\n")
	}
	
	regBuilder.WriteString("\t\tMiddlewareInstances: []axon.MiddlewareInstance{},\n") // TODO: Add middleware instances
	regBuilder.WriteString("\t\tParameterTypes:      map[string]string{},\n") // TODO: Add parameter types
	regBuilder.WriteString(fmt.Sprintf("\t\tHandler:             %s,\n", handlerVar))
	regBuilder.WriteString("\t})\n")
	
	return regBuilder.String(), nil
}