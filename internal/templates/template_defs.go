// Code generated by Axon framework refactor. DO NOT EDIT manually.
// This file contains template definitions organized by functionality.

package templates

// Provider Templates - Templates for generating FX provider functions
const (
	// ProviderTemplate is the template for generating FX provider functions
	ProviderTemplate = `func New{{.StructName}}({{range $i, $dep := .InjectedDeps}}{{if $i}}, {{end}}{{$dep.Name}} {{$dep.Type}}{{end}}) *{{.StructName}} {
	return &{{.StructName}}{
{{range .Dependencies}}{{if .IsInit}}		{{.FieldName}}: {{generateInitCode .Type}},
{{else}}		{{.FieldName}}: {{.Name}},
{{end}}{{end}}{{if not .Dependencies}}
{{end}}	}
}`

	// FXProviderTemplate is the template for generating FX provider functions with fx.In
	FXProviderTemplate = `func New{{.StructName}}() *{{.StructName}} {
	return &{{.StructName}}{
		
	}
}`

	// FXLifecycleProviderTemplate is the template for generating FX provider functions with fx.In and lifecycle
	FXLifecycleProviderTemplate = `func New{{.StructName}}(lc fx.Lifecycle{{range .Dependencies}}{{if not .IsInit}}, {{.Name}} {{.Type}}{{end}}{{end}}) *{{.StructName}} {
	service := &{{.StructName}}{
{{range .Dependencies}}{{if .IsInit}}		{{.FieldName}}: {{generateInitCode .Type}},
{{else}}		{{.FieldName}}: {{.Name}},
{{end}}{{end}}	}
	
	lc.Append(fx.Hook{
		OnStart: func(ctx context.Context) error {
			return service.Start(ctx)
		},{{if .HasStop}}
		OnStop: func(ctx context.Context) error {
			return service.Stop(ctx)
		},{{end}}
	})
	
	return service
}`

	// LifecycleProviderTemplate is the template for generating FX provider functions with lifecycle management
	LifecycleProviderTemplate = `func New{{.StructName}}(lc fx.Lifecycle{{range .Dependencies}}{{if not .IsInit}}, {{.Name}} {{.Type}}{{end}}{{end}}) *{{.StructName}} {
	service := &{{.StructName}}{
{{range .Dependencies}}{{if .IsInit}}		{{.FieldName}}: {{generateInitCode .Type}},
{{else}}		{{.FieldName}}: {{.Name}},
{{end}}{{end}}	}
	
	lc.Append(fx.Hook{
		OnStart: func(ctx context.Context) error {
			return service.Start(ctx)
		},{{if .HasStop}}
		OnStop: func(ctx context.Context) error {
			return service.Stop(ctx)
		},{{end}}
	})
	
	return service
}`

	// TransientProviderTemplate is the template for generating factory functions for transient services
	TransientProviderTemplate = `// New{{.StructName}}Factory creates a factory function for {{.StructName}} (Transient mode)
func New{{.StructName}}Factory({{range $i, $dep := .InjectedDeps}}{{if $i}}, {{end}}{{$dep.Name}} {{$dep.Type}}{{end}}) func() *{{.StructName}} {
	return func() *{{.StructName}} {
		return &{{.StructName}}{
{{range .Dependencies}}{{if .IsInit}}			{{.FieldName}}: {{generateInitCode .Type}},
{{else}}			{{.FieldName}}: {{.Name}},
{{end}}{{end}}{{if not .Dependencies}}
{{end}}		}
	}
}`

	// InitProviderTemplate is the template for generating simple providers for services with -Init flag
	InitProviderTemplate = `func New{{.StructName}}({{range $i, $dep := .InjectedDeps}}{{if $i}}, {{end}}{{$dep.Name}} {{$dep.Type}}{{end}}) *{{.StructName}} {
	return &{{.StructName}}{
{{range .Dependencies}}{{if .IsInit}}		{{.FieldName}}: {{generateInitCode .Type}},
{{else}}		{{.FieldName}}: {{.Name}},
{{end}}{{end}}{{if not .Dependencies}}
{{end}}	}
}`

	// InitInvokeTemplate is the template for generating invoke functions for lifecycle management
	InitInvokeTemplate = `func init{{.StructName}}Lifecycle(lc fx.Lifecycle, service *{{.StructName}}) {
	lc.Append(fx.Hook{
		OnStart: func(ctx context.Context) error {
{{if eq .StartMode "Background"}}			go func() {
				if err := service.Start(ctx); err != nil {
					// Log error or handle as needed
					// Note: Background start errors cannot be returned to FX
				}
			}()
			return nil
{{else}}			return service.Start(ctx)
{{end}}		},{{if .HasStop}}
		OnStop: func(ctx context.Context) error {
			return service.Stop(ctx)
		},{{end}}
	})
}`
)

// Logger Templates - Templates for generating logger provider functions
const (
	// LoggerProviderTemplate is the template for generating FX provider functions for loggers with immediate initialization
	LoggerProviderTemplate = `func New{{.StructName}}(lc fx.Lifecycle{{range .Dependencies}}{{if not .IsInit}}, {{.Name}} {{.Type}}{{end}}{{end}}) *{{.StructName}} {
	// Initialize logger immediately for fx.WithLogger to work
	var handler slog.Handler
	if {{.ConfigParam}}.LogLevel == "debug" {
		handler = slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
			Level: slog.LevelDebug,
		})
	} else {
		handler = slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
			Level: slog.LevelInfo,
		})
	}
	
	service := &{{.StructName}}{
{{range .Dependencies}}{{if .IsInit}}		{{.FieldName}}: slog.New(handler),
{{else}}		{{.FieldName}}: {{.Name}},
{{end}}{{end}}	}
	
	lc.Append(fx.Hook{
		OnStart: func(ctx context.Context) error {
			return service.Start(ctx)
		},{{if .HasStop}}
		OnStop: func(ctx context.Context) error {
			return service.Stop(ctx)
		},{{end}}
	})
	
	return service
}`

	// SimpleLoggerProviderTemplate is for loggers without lifecycle hooks
	SimpleLoggerProviderTemplate = `func New{{.StructName}}({{range $i, $dep := .InjectedDeps}}{{if $i}}, {{end}}{{$dep.Name}} {{$dep.Type}}{{end}}) *{{.StructName}} {
	// Initialize logger immediately
	var handler slog.Handler
	if {{.ConfigParam}}.LogLevel == "debug" {
		handler = slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
			Level: slog.LevelDebug,
		})
	} else {
		handler = slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
			Level: slog.LevelInfo,
		})
	}
	
	return &{{.StructName}}{
{{range .Dependencies}}{{if .IsInit}}		{{.FieldName}}: slog.New(handler),
{{else}}		{{.FieldName}}: {{.Name}},
{{end}}{{end}}	}
}`
)

// Interface Templates - Templates for generating interfaces and interface providers
const (
	// InterfaceTemplate is the template for generating interfaces from structs
	InterfaceTemplate = `// {{.Name}} is the interface for {{.StructName}}
type {{.Name}} interface {
{{range .Methods}}	{{.Name}}({{range $i, $param := .Parameters}}{{if $i}}, {{end}}{{if $param.Name}}{{$param.Name}} {{end}}{{$param.Type}}{{end}}){{if .Returns}} ({{range $i, $ret := .Returns}}{{if $i}}, {{end}}{{$ret}}{{end}}){{end}}
{{end}}}`

	// InterfaceProviderTemplate is the template for generating FX provider that casts struct to interface
	InterfaceProviderTemplate = `func New{{.Name}}(impl *{{.StructName}}) {{.Name}} {
	return impl
}`
)

// Module Templates - Templates for generating FX modules and related components
const (
	// FXLoggerAdapterTemplate is the template for generating FX logger adapter
	FXLoggerAdapterTemplate = `// fxLogger adapts {{.LoggerStructName}} to fxevent.Logger
type fxLogger struct {
	logger *{{.LoggerStructName}}
}

// LogEvent implements fxevent.Logger interface
func (l *fxLogger) LogEvent(event fxevent.Event) {
	switch e := event.(type) {
	case *fxevent.OnStartExecuting:
		l.logger.Info("OnStart hook executing", "callee", e.FunctionName, "caller", e.CallerName)
	case *fxevent.OnStartExecuted:
		if e.Err != nil {
			l.logger.Error("OnStart hook failed", "callee", e.FunctionName, "caller", e.CallerName, "error", e.Err)
		} else {
			l.logger.Info("OnStart hook executed", "callee", e.FunctionName, "caller", e.CallerName, "runtime", e.Runtime)
		}
	case *fxevent.OnStopExecuting:
		l.logger.Info("OnStop hook executing", "callee", e.FunctionName, "caller", e.CallerName)
	case *fxevent.OnStopExecuted:
		if e.Err != nil {
			l.logger.Error("OnStop hook failed", "callee", e.FunctionName, "caller", e.CallerName, "error", e.Err)
		} else {
			l.logger.Info("OnStop hook executed", "callee", e.FunctionName, "caller", e.CallerName, "runtime", e.Runtime)
		}
	case *fxevent.Supplied:
		l.logger.Debug("supplied", "type", e.TypeName, "module", e.ModuleName)
	case *fxevent.Provided:
		l.logger.Debug("provided", "constructor", e.ConstructorName, "module", e.ModuleName)
	case *fxevent.Invoking:
		l.logger.Debug("invoking", "function", e.FunctionName, "module", e.ModuleName)
	case *fxevent.Invoked:
		if e.Err != nil {
			l.logger.Error("invoke failed", "error", e.Err, "stack", e.Trace, "function", e.FunctionName, "module", e.ModuleName)
		} else {
			l.logger.Debug("invoked", "function", e.FunctionName, "module", e.ModuleName)
		}
	case *fxevent.Stopping:
		l.logger.Info("received signal", "signal", e.Signal)
	case *fxevent.Stopped:
		if e.Err != nil {
			l.logger.Error("stop failed", "error", e.Err)
		} else {
			l.logger.Info("stopped")
		}
	case *fxevent.RollingBack:
		l.logger.Error("start failed, rolling back", "error", e.StartErr)
	case *fxevent.RolledBack:
		if e.Err != nil {
			l.logger.Error("rollback failed", "error", e.Err)
		} else {
			l.logger.Info("rolled back")
		}
	case *fxevent.Started:
		if e.Err != nil {
			l.logger.Error("start failed", "error", e.Err)
		} else {
			l.logger.Info("started")
		}
	case *fxevent.LoggerInitialized:
		if e.Err != nil {
			l.logger.Error("custom logger initialization failed", "error", e.Err)
		} else {
			l.logger.Debug("initialized custom fxevent.Logger", "function", e.ConstructorName)
		}
	}
}`

	// ModuleHeaderTemplate is the template for generating module file headers
	ModuleHeaderTemplate = `// Code generated by Axon framework. DO NOT EDIT.
// This file was automatically generated and should not be modified manually.

package {{.PackageName}}

import (
{{range .StandardImports}}	"{{.}}"
{{end}}{{if .StandardImports}}
{{end}}{{range .ThirdPartyImports}}	"{{.}}"
{{end}}{{if .ThirdPartyImports}}
{{end}}{{range .LocalImports}}	"{{.}}"
{{end}})
`

	// ModuleDefinitionTemplate is the template for generating FX module definitions
	ModuleDefinitionTemplate = `// AutogenModule provides all core services in this package
var AutogenModule = fx.Module("{{.PackageName}}",
{{if .HasLogger}}	fx.WithLogger(func(logger *{{.FirstLoggerStruct}}) fxevent.Logger {
		return &fxLogger{logger: logger}
	}),
{{end}}{{range .Providers}}	{{.}},
{{end}})`
)