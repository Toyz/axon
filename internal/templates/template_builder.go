package templates

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"

	"github.com/toyz/axon/internal/errors"
)

// generateInitCode generates initialization code for a given type
func generateInitCode(fieldType string) string {
	// Remove pointer prefix for analysis
	baseType := strings.TrimPrefix(fieldType, "*")

	// Handle different types
	if strings.HasPrefix(baseType, "map[") {
		return fmt.Sprintf("make(%s)", fieldType)
	} else if strings.HasPrefix(baseType, "[]") {
		return fmt.Sprintf("make(%s, 0)", fieldType)
	} else if strings.Contains(baseType, "chan ") {
		return fmt.Sprintf("make(%s)", fieldType)
	} else if strings.HasPrefix(fieldType, "*") {
		// For pointer types, use nil (they should be initialized in lifecycle methods)
		return "nil"
	} else {
		// For value types, use zero value constructor
		return fmt.Sprintf("%s{}", fieldType)
	}
}

// TemplateBuilder provides a fluent interface for template generation
// eliminating duplication across Generate* functions
type TemplateBuilder struct {
	templateName string
	templateText string
	subTemplates map[string]string // for complex templates with sub-templates
	data         interface{}
	imports      *ImportManager
	header       string
	footer       string
}

// NewTemplateBuilder creates a new template builder
func NewTemplateBuilder(templateName string) *TemplateBuilder {
	return &TemplateBuilder{
		templateName: templateName,
		subTemplates: make(map[string]string),
		imports:      NewImportManager(),
		header:       "// Code generated by Axon framework. DO NOT EDIT.\n// This file was automatically generated and should not be modified manually.\n\n",
	}
}

// WithTemplate sets the template text to use
func (tb *TemplateBuilder) WithTemplate(templateText string) *TemplateBuilder {
	tb.templateText = templateText
	return tb
}

// WithRegistryTemplate uses a template from the registry
func (tb *TemplateBuilder) WithRegistryTemplate(templateKey string) *TemplateBuilder {
	tb.templateText = DefaultTemplateRegistry.MustGet(templateKey)
	return tb
}

// WithSubTemplate adds a sub-template from the registry
func (tb *TemplateBuilder) WithSubTemplate(name, templateKey string) *TemplateBuilder {
	tb.subTemplates[name] = DefaultTemplateRegistry.MustGet(templateKey)
	return tb
}

// WithData sets the data to pass to the template
func (tb *TemplateBuilder) WithData(data interface{}) *TemplateBuilder {
	tb.data = data
	return tb
}

// WithImports adds import paths
func (tb *TemplateBuilder) WithImports(imports ...string) *TemplateBuilder {
	for _, imp := range imports {
		tb.imports.AddImport(imp)
	}
	return tb
}

// WithPackageImports adds package imports with aliases
func (tb *TemplateBuilder) WithPackageImports(packages map[string]string) *TemplateBuilder {
	for alias, path := range packages {
		tb.imports.AddPackageImport(alias, path)
	}
	return tb
}

// WithModuleImport sets the module import
func (tb *TemplateBuilder) WithModuleImport(moduleImport string) *TemplateBuilder {
	tb.imports.SetModuleImport(moduleImport)
	return tb
}

// WithUserPackages adds user packages
func (tb *TemplateBuilder) WithUserPackages(packages ...string) *TemplateBuilder {
	tb.imports.AddUserPackages(packages...)
	return tb
}

// WithHeader sets a custom header (default is auto-generated comment)
func (tb *TemplateBuilder) WithHeader(header string) *TemplateBuilder {
	tb.header = header
	return tb
}

// WithFooter sets a custom footer
func (tb *TemplateBuilder) WithFooter(footer string) *TemplateBuilder {
	tb.footer = footer
	return tb
}

// Build executes the template and returns the generated code
func (tb *TemplateBuilder) Build() (string, error) {
	if tb.templateText == "" {
		return "", fmt.Errorf("template text not set")
	}

	// Create template with custom functions (same as in executeTemplate)
	utils := DefaultTemplateUtils
	funcMap := template.FuncMap{
		"generateInitCode": generateInitCode,
		"toCamelCase":      utils.ToCamelCase,
	}

	// Parse and execute template
	tmpl, err := template.New(tb.templateName).Funcs(funcMap).Parse(tb.templateText)
	if err != nil {
		return "", errors.WrapTemplateError(tb.templateName, "parse", err)
	}

	// Add sub-templates if any
	for name, templateText := range tb.subTemplates {
		_, err = tmpl.New(name).Parse(templateText)
		if err != nil {
			return "", errors.WrapTemplateError(tb.templateName+"."+name, "parse", err)
		}
	}

	var contentBuffer bytes.Buffer
	if err := tmpl.Execute(&contentBuffer, tb.data); err != nil {
		return "", errors.WrapTemplateError(tb.templateName, "execute", err)
	}

	content := contentBuffer.String()

	// Build final result
	var result strings.Builder

	// Add header
	if tb.header != "" {
		result.WriteString(tb.header)
	}

	// Add imports if any content requires them
	if strings.TrimSpace(content) != "" {
		importsSection := tb.imports.GenerateImports()
		if importsSection != "" {
			result.WriteString(importsSection)
			result.WriteString("\n")
		}
	}

	// Add main content
	result.WriteString(content)

	// Add footer
	if tb.footer != "" {
		result.WriteString(tb.footer)
	}

	return result.String(), nil
}

// BuildContent executes the template and returns only the content (no imports/header)
func (tb *TemplateBuilder) BuildContent() (string, error) {
	if tb.templateText == "" {
		return "", fmt.Errorf("template text not set")
	}

	// Create template with custom functions (same as in executeTemplate)
	utils := DefaultTemplateUtils
	funcMap := template.FuncMap{
		"generateInitCode": generateInitCode,
		"toCamelCase":      utils.ToCamelCase,
	}

	tmpl, err := template.New(tb.templateName).Funcs(funcMap).Parse(tb.templateText)
	if err != nil {
		return "", errors.WrapTemplateError(tb.templateName, "parse", err)
	}

	// Add sub-templates if any
	for name, templateText := range tb.subTemplates {
		_, err = tmpl.New(name).Parse(templateText)
		if err != nil {
			return "", errors.WrapTemplateError(tb.templateName+"."+name, "parse", err)
		}
	}

	var buffer bytes.Buffer
	if err := tmpl.Execute(&buffer, tb.data); err != nil {
		return "", errors.WrapTemplateError(tb.templateName, "execute", err)
	}

	return buffer.String(), nil
}

// GetImportManager returns the import manager for advanced usage
func (tb *TemplateBuilder) GetImportManager() *ImportManager {
	return tb.imports
}